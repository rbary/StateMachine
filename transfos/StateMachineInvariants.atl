module StateMachineFirstExe;
create result: MM from model: MM;

-- ******************************---
-- HELPERS IMPL OCL CONSTRAINTS	 ---
-- ******************************---

-- For each model, there is a unicity of a StateMachine instanciation being ---
-- the starting to the creation and optimization of all the states and transitions of the
		-- model --
helper context MM!StateMachine def: stateMachineUnicity(): Boolean =
	self.allInstances() -> select(s | s.oclIsTypeOf(MM!StateMachine)) -> size() = 1;

-- The state referenced by an initial state of a composite is a state of the composite --
helper context MM!CompositeState def: refInitStateBelongComposite: Boolean =
	self.states() -> include(self.initialState.referencedState);

-- Wether a StateMachine is active then it contains a only one active state and if --
-- this state is Composite it contains a only one active state and so on           --
helper context MM!StateMachine def: activeStateRecursion(): Boolean =
	self.isActive and self.activeSubTree();

helper context MM!CompositeState def: activeSub(): Boolean =
	self.states -> select(s | s.isActive) -> size() = 1 and self.states -> select(s | s.
			oclIsTypeOf(MM!CompositeState)) -> forAll(s | if s.isActive then
			s.activeSub()
		else
			s.unactiveSub()
		endif);

helper context MM!CompositeState def: unactiveSub(): Boolean =
	self.states -> forAll(s | not s.isActive) and self.states -> select(s | s.
			oclIsTypeOf(MM!CompositeState)) -> forAll(s | s.unactiveSub);

-- There are no two states having the same name within a composite --
helper context MM!CompositeState def: stateDiscreetName(): Boolean =
	self.states -> forAll(s0 | self.states -> forAll(s1 | s0.name = s1.name implies s0 =
			s1));

-- ******************************---
--            RULES				 ---
-- ******************************---
---------- STATEMACHINE ----------
rule duplicateStateMachine {
	from
		source_statemachine: MM!StateMachine (
			source_statemachine.stateMachineUnicity() and 
			source_statemachine.activeStateRecursion()
		)
	to
		target_statemachine: MM!StateMachine (
			name <- source_statemachine.name,
			container <- source_statemachine.container,
			isActive <- source_statemachine.isActive,
			operation <- source_statemachine.operation,
			states <- source_statemachine.states,
			initialState <- source_statemachine.initialState,
			transitions <- source_statemachine.transitions,
			events <- source_statemachine.events,
			variables <- source_statemachine.variables
		)
}

rule NotduplicateStateMachine {
	from
		source_statemachine: MM!StateMachine (
			not(source_statemachine.stateMachineUnicity() and 
				source_statemachine.activeStateRecursion())
		)
	to
		target_statemachine: MM!StateMachine (
			name <- source_statemachine.name,
			container <- source_statemachine.container,
			isActive <- source_statemachine.isActive,
			operation <- source_statemachine.operation,
			states <- source_statemachine.states,
			initialState <- source_statemachine.initialState,
			transitions <- source_statemachine.transitions,
			events <- source_statemachine.events,
			variables <- source_statemachine.variables
		),
		error : target_statemachine!ConstraintError (
			description <- 'There is more than one StateMachine in the model or There is no active state recursion from a StateMachine',
			element <- target_statemachine
		)
}

----------- STATE ----------------
rule duplicateState { 
from
	 source_state : MM!State (source_state.oclIsTypeOf(MM!State))
to
	 target_state : MM!State(
	 	 name <- source_state.name,
	 	 container <- source_state.container,
	 	 isActive <- source_state.isActive,
	 	 operation <- source_state.operation
	 )
}

---------- COMPOSITE_STATE -------------------
rule duplicateCompositeState { 
from
	 source_compositestate : MM!CompositeState (
	 					source_compositestate.oclIsTypeOf(MM!CompositeState) and
						source_compositestate.refInitStateBelongComposite()
					 )
to
	 target_compositeState : MM!CompositeState(
	 	 name <- source_compositestate.name,
	 	 container <- source_compositestate.container,
	 	 isActive <- source_compositestate.isActive,
	 	 operation <- source_compositestate.operation,
	 	 states <- source_compositestate.states,
	 	 initialState <- source_compositestate.initialState
	 )
}


rule NotduplicateCompositeState { 
from
	 source_compositestate : MM!CompositeState (
	 					not (	source_compositestate.oclIsTypeOf(MM!CompositeState) and
	 							source_compositestate.refInitStateBelongComposite()	
	 						 
	 						)
					 )
to
	 target_compositestate : MM!CompositeState(
	 	 name <- source_compositestate.name,
	 	 container <- source_compositestate.container,
	 	 isActive <- source_compositestate.isActive,
	 	 operation <- source_compositestate.operation,
	 	 states <- source_compositestate.states,
	 	 initialState <- source_compositestate.initialState
	 ),
	 error : target_compositestate!ConstraintError(
	 	description <- 'The state referenced by an initial state of a composite is not a state of the current composite or the source type is not CompositeState',
			 element <- target_compositestate
	 )
}



---------- INITIALSTATE ----------

rule duplicateInitialState { 
from
	 sourceInitialState : MM!InitialState
to
	 targetInitialState : MM!InitialState(
	 	 referencedState <- sourceInitialState.referencedState
	 )
} 


---------- TRANSITION ----------

rule duplicateTransition { 
from
	 sourceTransition : MM!Transition
to
	 targetTransition : MM!Transition(
	 	 source <- sourceTransition.source,
	 	 target <- sourceTransition.target,
	 	 event <- sourceTransition.event,
	 	 guard <- sourceTransition.guard
	 )
} 


---------- EVENT ----------

rule duplicateEvent { 
from
	 sourceEvent : MM!Event
to
	 targetEvent : MM!Event(
	 	 name <- sourceEvent.name
	 )
} 


---------- EXPRESSION ----------

rule duplicateExpression { 
from
	 sourceExpression : MM!Expression
to
	 targetExpression : MM!Expression(
	 	 left <- sourceExpression.left,
	 	 right <- sourceExpression.right,
	 	 operator <- sourceExpression.operator,
	 	 _name <- sourceExpression._name
	 )
} 


---------- BOOLEANDATA ----------

rule duplicateBooleanData { 
from
	 sourceBooleanData : MM!BooleanData
to
	 targetBooleanData : MM!BooleanData(
	 	 value <- sourceBooleanData.value
	 )
} 


---------- INTEGERDATA ----------

rule duplicateIntegerData { 
from
	 sourceIntegerData : MM!IntegerData
to
	 targetIntegerData : MM!IntegerData(
	 	 value <- sourceIntegerData.value
	 )
} 


---------- BOOLEANVARIABLE ----------

rule duplicateBooleanVariable { 
from
	 sourceBooleanVariable : MM!BooleanVariable
to
	 targetBooleanVariable : MM!BooleanVariable(
	 	 value <- sourceBooleanVariable.value,
	 	 name <- sourceBooleanVariable.name
	 )
} 


---------- INTEGERVARIABLE ----------

rule duplicateIntegerVariable { 
from
	 sourceIntegerVariable : MM!IntegerVariable
to
	 targetIntegerVariable : MM!IntegerVariable(
	 	 value <- sourceIntegerVariable.value,
	 	 name <- sourceIntegerVariable.name
	 )
} 


---------- OPERATION ----------

rule duplicateOperation { 
from
	 sourceOperation : MM!Operation
to
	 targetOperation : MM!Operation(
	 	 contents <- sourceOperation.contents
	 )
} 


---------- ASSIGNMENT ----------

rule duplicateAssignment { 
from
	 sourceAssignment : MM!Assignment
to
	 targetAssignment : MM!Assignment(
	 	 expression <- sourceAssignment.expression,
	 	 variable <- sourceAssignment.variable,
	 	 _name <- sourceAssignment._name
	 )
} 


---------- VARIABLEREFERENCE ----------

rule duplicateVariableReference { 
from
	 sourceVariableReference : MM!VariableReference
to
	 targetVariableReference : MM!VariableReference(
	 	 variable <- sourceVariableReference.variable,
	 	 _name <- sourceVariableReference._name
	 )
} 











